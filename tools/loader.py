#Author: Anderson Zudio
#Version: 1.0
#Date: 15 june 2022
#This module does nothing by itself. This is part of execution-battery.py and execution-battery-analyser.py. 

#--Description--
#This script contains the necessary auxiliary functions and variables to load the following dependencies of both execution battery modules based on the problem at hand:
#Identify input, output, and error file extensions;
#Provide a function that read a solution from a file object;
#Provide a function that compare two solutions that have been read with the function above;
#Provide a function that tells if a solution that have been read with th ise functio above is invalid;
#Provide a function that tells the column names (header) of the result table (summary);
#Provide a function that extract the info for the result table based on a solution list. The info should be sorted accordingly based on the header.

#--Usage--
#This shouldn't contain code that executes by itself. It should provide a "load" function that receives a problem acronym to return a dict with the following information:
# "read_function": function  -- A function that can read a solution from a file object.
# "compare_function": function -- A function that compare two input solutions to answer if the first is stritcly better than the second.
# "check_function": function -- Answers if the solution is invalid. Every invalid solution should be ignored. If you're the responsible for the application that solves the problem at hand, it is recommended to check solution validity in the solver itself and register it on the solution file, therefore this function will only reflect the information that is on the file.
# "header_function": function -- The column table summary that should appear in the output of the analyzer. See the analyzer tool for details.
# "entry_function": function -- The function that computes an entry of the table generated by the analyzer. See the analyzer tool for details.
# "in_extension": string -- The extension of an instance file of the problem at hand.
# "out_extension": string -- The extension of a solution file of the problem at hand.
# "err_extension": string -- An extension that should be used for the stderr output of the application being executed.
# "bks_extension": string -- An extension that should be used for the best known solution maintance. See the execution battery tool for details.
#If the user need to insert a new problem into the project, this is the only tool that should be modified.
#Any class below can be modified. They serve as examples.

import statistics

class TSPLoader: #Contains the definition of every dependency of the TSP problem. 
    in_extension = ".tsp"
    out_extension = ".tsp.out"
    err_extension = ".tsp.err"
    bks_extension = ""

    #Receives an object file. Should output a solution representation that can be read in the remaining funcitons.
    @staticmethod
    def tspReadSolution(solution_file):
        name = solution_file.readline().rstrip()
        vertex_order_string = solution_file.readline().rstrip()
        vertex_order = []
        for word in vertex_order_string:
            if(word != " "):
                vertex_order.append(int(word))
        total_distance = float(solution_file.readline().rstrip())
        method = solution_file.readline().rstrip()
        last_line_list = solution_file.readline().rstrip().split()
        execution_time = float(last_line_list[0])
        iteration_count = int(last_line_list[1])
        solution = {
            "name": name,
            "distance": total_distance,
            "method": method,
            "time": execution_time,
            "iteration": iteration_count,
            "order": vertex_order
        };
        return solution

    #Receive two solutions as input. Should return if the first one is strictly better than the second.
    @staticmethod
    def tspCompare(solution, bks):
        if(solution["distance"] < bks["distance"]):
            return True
        else:
            return False

    #Receive a solution. Should return True if it's valid, False otherwise.
    @staticmethod
    def tspCheckSolution(solution):
        return True

    #Return the header (column names) of the summary table. The info has to be properly sorted.
    @staticmethod
    def tspHeader():
        return ['Avg execution time (s) (MIN/MAX) [std_dev]', 'Avg iteration count (MIN/MAX) [std_dev]', 'Avg distance (MIN/MAX) [std_dev]']

    #Receive a solution list. Should output the info for the result table. This info has to be in the same order as the header given above.
    @staticmethod
    def tspAddEntry(solution_list):
        execution_time = []
        iteration_count = []
        distance = []

        for solution in solution_list:
            execution_time.append(solution["time"])
            iteration_count.append(solution["iteration"])
            distance.append(solution["distance"])

        execution_time_avg = round(statistics.mean(execution_time), 1)
        execution_time_dev = round(statistics.stdev(execution_time), 1)
        execution_time_min = round(min(execution_time), 1)
        execution_time_max = round(max(execution_time), 1)
        iteration_count_avg = round(statistics.mean(iteration_count), 1)
        iteration_count_dev = round(statistics.stdev(iteration_count), 1)
        iteration_count_min = min(iteration_count)
        iteration_count_max = max(iteration_count)
        distance_avg = round(statistics.mean(distance), 1)
        distance_dev = round(statistics.stdev(distance), 1)
        distance_min = min(distance)
        distance_max = max(distance)

        return [str(execution_time_avg) + ' (' + str(execution_time_min) + '/' + str(execution_time_max) + ') [' + str(execution_time_dev) + ']', str(iteration_count_avg) + ' (' + str(iteration_count_min) + '/' + str(iteration_count_max) + ') [' + str(iteration_count_dev) + ']', str(distance_avg) + ' (' + str(distance_min) + '/' + str(distance_max) + ') [' + str(distance_dev) + ']' ]
        
#The main function that should be called from other tools. This should setup the variables to specify the dependencies
def load(problem_name):
    if(problem_name == "tsp"):
        return {
            "read_function": TSPLoader.tspReadSolution,
            "compare_function": TSPLoader.tspCompare,
            "check_function": TSPLoader.tspCheckSolution,
            "header_function": TSPLoader.tspHeader,
            "entry_function": TSPLoader.tspAddEntry,
            "in_extension": TSPLoader.in_extension,
            "out_extension": TSPLoader.out_extension,
            "err_extension": TSPLoader.err_extension,
            "bks_extension": TSPLoader.bks_extension,
        }
    else: #unknown problem
        return {}