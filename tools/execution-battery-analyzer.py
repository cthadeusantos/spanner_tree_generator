#Author: Anderson Zudio
#Version: 3.0
#Date: 15 june 2022
#Extends: execution-battery.py at version 3.0.
#Dependency: loader.py and Prettytable (pip3 install prettytable).

#--Description--
#This tool receives the path of a folder generated by the execution battery script through command line argument to devise a file with a result summary of the execution.
#The idea is to have a full result table based on the problem at hand. This table should be formatted and easily manipulated for exibition purposes on other works.
#This scrit itself should be rarely edited. The user will have to program the loader.py instead to satisfy the following dependencies based on the problem at hand:
#   File extensions: the loader module should tell which file extensions to use for input, output, and error log.
#   Additional functions: the loader module should provide functions to describe the table header and to fill the information of each row based.
#   The input of the loader tool is an acronym of the problem, like "tsp" for example. The module itself should have at least one example that the user can modify for its own needs.

#--Aplication Usage--
#python3 execution-battery.py {EXECUTION_BATTERY_DIR}
#The execution battery tool generates a {EXECUTION_BATTERY_DIR} folder, which should be passed through command line. A single log file is expected inside this folder.
#The output will be writen to a file called "result_summary.txt" inside the {EXECUTION_BATTERY_DIR}.
#This script uses stderr to exibit some script execution information. You may use it for debugging purposes.
#The main result table will always have 3 columns that are managed by this script:
#   Instance name: the original instance that has been used.
#   Subdir: the directory where the test battery files reside related to the {EXECUTION_BATTERY_DIR}.
#   Number of total runs and success: self explanatory.
#The remaning information should be filled with the information provided by the loader.py. 
#The user has to provide the remaning column names through a function alongside a way to extract its info based on the solution list read from the test battery.
#The implementation details of these two functions can be seen as examples on the loader.py module itself. The user may use the existing code on the module to adapt to its own necessities based on the problem at hand.

#--Warning--
#The target folder has to have a single log file at root generated by the execution battery tool. You can devise the file manually, but it isn't recommended to. See the execution battery tool for details about the structure of the log file.
#This script should rarely be edited. If you need to work with a new problem within the project, then you need to edit the loader.py.
#Do not manually edit the log file or modify the folder structure devised by the original full_execution.py unless you know what you are doing. It has a standard. It may break other tools if not handled correctly.

import sys
import os
import prettytable
import loader

#--Global variables--
#Common directories that are used in the script
instance_base_dir = "../instances/" #The directory that has the instances

#Parameters to be loaded
main_dir = None #Directory loaded from the command line argument. It should contain the log file and all the full execution result
log_file = None #The main log file that is being read.
summary_file = None #Will have the main file that is being written

#Execution identifier
problem_name = "" #Loaded from the log file. This will dictate how the table will look and what information should be stored in the output

#Problem dependent variables. They're all loaded from loader.py. Check that tool if you need additional details.
in_extension = "" #Will hold the extension of the input files of the problem. 
out_extension = "" #Will hold the extension of the output files of the problem. 
err_extension = "" #Will hold the extension of the err files of the problem. 
read_solution = None #Will hold a function that can read a solution for the current problem from a file.
add_headings = None #Should store the header of the column that will go into the table. For example, if you problem logs the quality of the final solution as a real value, you may want to exibit in this summary the mean, max, min, and std dev devised by the test battery. Therefore, this function should output a list with the 4 respective headers in order: ['avg', 'min', 'max', 'std dev'].
add_entry = None #Will hold a function that receives a list with solutions to the information expected of each column. This information will be used to fill the table. For example, consider the cenary in the line above. For these headers, you should output a list with the avg, min, max, and std dev devised by the test battery run sorted in this order. 
table = prettytable.PrettyTable() #Will hold the table that should be sys.stderr.writeed. The loader class should put the first row

#Other variables
total_instances = 0 #How many instances were processed from the log
instances_not_found = [] #What instances were reported as not found
instances_error = [] #What instances reported at least one error in some run

#--Functions that shouldn't be changed--
def loadParam(): #Load the summary file from the command line argument
    global main_dir
    global log_file
    if len(sys.argv) < 2:
        sys.stderr.write("Expecting the folder path as argument. Read the script for details.")
        exit(0)
    main_dir = sys.argv[1]
    if(main_dir[-1] != os.sep):
        main_dir += os.sep
    sys.stderr.write("Main directory: " + main_dir + '\n')
    if not os.path.exists(main_dir):
        sys.stderr.write("The " + main_dir + " directory doesn't exist. Aborting execution.\n")
        exit(0)
    sys.stderr.write("The directory has been found. Opening log file from " + main_dir + "\n")
    error = True #signals if the log file is missing
    for path, directory, files in os.walk(main_dir):
        for file in files:
            if(file.endswith(".log")):
                sys.stderr.write("Log file found: " + path + file + "\n")
                log_file = open(os.path.join(path, file), "r")
                error = False
    if error:
        sys.stderr.write("Log file is missing. Aborting execution.\n")
        exit(0)

def loadInfo(): #Load important info from the log file and save it in the summary file
    global log_file
    global summary_file
    global problem_name
    sys.stderr.write("Loading problem name and run name\n")
    line = log_file.readline()
    line = line.split(' ')
    problem_name = line[5].rstrip()
    run_name = line[7].rstrip()
    sys.stderr.write("Problem name: " + problem_name + "\nExecution run name: " + run_name + '\n')
    description_line = log_file.readline() 
    execution_date = ''
    description = ''
    if("Test battery description: " in description_line):
        description = description_line.replace("Test battery description: ", '').rstrip()
        sys.stderr.write("Test battery description: " + description + '\n')
        execution_date = log_file.readline().replace("Current date: ", '').rstrip()
    else:
        execution_date = description_line.replace("Current date: ", '').rstrip()
    sys.stderr.write("Execution date: " + execution_date + '\n')
    operational_system = log_file.readline().replace("Current operational system: ", '').rstrip()
    sys.stderr.write("Operational system: " + operational_system + '\n')
    cpu_info = log_file.readline().replace("Current CPU information: ", '').rstrip()
    sys.stderr.write("CPU used: " + cpu_info + '\n')
    ram = log_file.readline().replace("Amount of RAM (gb): ", '').rstrip()
    ram = float(ram)
    ram = str(round(ram))
    sys.stderr.write("Physical memory available: " + ram + " GB of RAM\n")
    executable_name = log_file.readline().replace("Binary executable file name: ", '').rstrip().split('/')[-1]
    sys.stderr.write("Binary executable name: " + executable_name + '\n')
    args = log_file.readline().replace("Default argument list: ", '').rstrip()
    sys.stderr.write("Default argument list: " + args + '\n')
    timelimit = int(log_file.readline().replace("Default run time limit in seconds: ", '').rstrip())
    sys.stderr.write("Default timelimit in seconds: " + str(timelimit) + '\n')
    runs = int(log_file.readline().replace("Default number of runs: ", '').rstrip())
    sys.stderr.write("Default number of executions: " + str(runs) + '\n')
    seed = int(log_file.readline().replace("Default starting seed: ", '').rstrip())
    sys.stderr.write("Default starting seed: " + str(seed) + '\n')
    n_instances = int(log_file.readline().replace("Amount of instances given in the input: ", '').rstrip())
    sys.stderr.write("Total number of instances in the test battery: " + str(n_instances) + '\n')
    target_folder = log_file.readline().replace("Run folder name: ", '').rstrip()
    sys.stderr.write("Main directory: " + target_folder + '\n')
    log_file.readline() #Unused. This line tells if bks was enabled.

    summary_file.write("This is a test battery for " + problem_name + " ran at " + execution_date + "\n")
    if(description != ''):
        summary_file.write("Test description: " + description + '\n')
    summary_file.write("Computational environment: " + cpu_info + " with " + str(ram) + " GB of RAM running in " + operational_system + '\n')
    summary_file.write("Original binary file name: " + executable_name + '\n')
    summary_file.write("Default arguments given: " + args + '\n')
    summary_file.write("Default number of independent runs: " + str(runs) + ' -- Default timelimit in seconds for each run: ' + str(timelimit) + ' -- Default starting seed: ' + str(seed) + '\n')
    summary_file.write('Amount of instances in this test battery: ' + str(n_instances) + '\n')
    summary_file.write('Details about each failed run, overriden arguments, or repeated instances should be seen in the respective log file. You may also use the original json archived here for this same purpose.\n\n')

def loadProblemInfo(): #Will load every info that is based on the problem. Check loader.py
    global in_extension
    global out_extension
    global err_extension
    global read_solution
    global add_headings 
    global add_entry

    dependency = loader.load(problem_name)
    if(not bool(dependency)):
        sys.stderr.write("The problem " + problem_name + " hasn't been identified in the loader.py script. Aborting execution.\n")
        exit()
    else:
        read_solution = dependency["read_function"] 
        in_extension = dependency["in_extension"]
        out_extension = dependency["out_extension"] 
        err_extension = dependency["err_extension"] 
        add_headings = dependency["header_function"]
        add_entry = dependency["entry_function"]
        sys.stderr.write("Dependencies for " + problem_name + " loaded successfully.\n")
        sys.stderr.write("In file extension: " + in_extension + "\n")
        sys.stderr.write("Out file extension: " + out_extension + "\n")
        sys.stderr.write("Error file extension: " + err_extension + "\n")

def loadInstanceListInfo(): #Will iterate over the log and identify each subfolder to read its solution. Also, this will create the table.
    global table
    global in_extension
    global total_instances
    global instances_not_found
    log_file_error = False
    wrong_line = ''
    sys.stderr.write("Adding the table header.\n")
    table.field_names = ["Instance Name", "Subdir", "#Successes/#TotalRuns"] + add_headings()
    sys.stderr.write("Full table header: " + str(table.field_names) + '\n')

    while(True):
        line = log_file.readline()
        if line == "" or line == "\n" or line == "Successfully Finished.\n" or line == "Successfully Finished.":
            sys.stderr.write("Reached EOF of log_file. If the number of entrys at the summary table doesn't match the number of instances in the json input, check for errors or manual edits to the respective log file.\n")
            break
        elif line.split(' ')[0] == "Processing":
            total_instances += 1
            instance_name = line.split(' ')[2].replace(instance_base_dir, '') 
            sys.stderr.write("Processing instance: " + instance_name + '\n')
            if "Instance not found" in line:
                sys.stderr.write("Instance hasn't been found! Skipping.\n")
                instances_not_found.append(instance_base_dir + instance_name)
            else:
                has_override = "Overriding" in line
                is_repeated = "Repeated" in line
                line = log_file.readline()
                if 'Starting' in line:
                    sys.stderr.write("Reading instance path.\n")
                    instance_path = main_dir + line.split()[8][:-1]
                    if instance_path[-1] != os.sep:
                        instance_path += os.sep
                    sys.stderr.write("Checking if instance folder exists: " + instance_path  + ".\n")
                    if not os.path.exists(instance_path):
                        sys.stderr.write("Instance path expected and not found. Possibly manually removed or renamed. Check for possible errors in the log_file.\n")
                        sys.stderr.write("Expected folder: " + instance_path + '\nAborting Execution.\n')
                        exit(0)
                    sys.stderr.write("Instance folder found.\n")
                    n_run = int(line.split(' ')[3])
                    sys.stderr.write("Processing execution info. Number of runs: " + str(n_run) + "\n")
                    entry = loadEntry(instance_name, instance_path, n_run)
                    if has_override:
                        entry[0] = '!' + entry[0] 
                    if is_repeated:
                        entry[0] = '#' + entry[0] 
                    sys.stderr.write("Adding the following row to the table: " + str(entry) + '\n')
                    table.add_row(entry)
                else:
                    log_file_error = True
                    wrong_line = line
                    break
        else:
            log_file_error = True
            wrong_line = line
            break
        
        if log_file_error:
            sys.stderr.write("The summary file can't be finished. The log has been manually edit and has unexpected information. Check it carefully.\n")
            sys.stderr.write("Problematic line: " + wrong_line.rstrip() + '\n')
            sys.stderr.write("Aborting execution.\n")
            log_file.close()
            summary_file.close()
            exit(0)

def loadEntry(name, path, n_run): #Receives the instance file path to output a new entry for the table
    global log_file
    global instances_error
    global instance_base_dir
    global in_extension
    global out_extension
    global read_solution
    global add_entry

    solution_list = []
    solution_file = None
    has_bks = False
    error = False    
    n_suc = 0

    for i in range(n_run):
        line = log_file.readline()
        line_list = line.split(' ')
        #############################
        # Adicionada para evitar erro se não houver dados nos
        # arquivos N.out.txt , where N is a integer
        if line_list[0] == '':
            continue
        #############################
        seed = int(line_list[7].rstrip('.'))
        if line_list[9] == "success.":
            sys.stderr.write("Success... ")
            n_suc += 1
            solution_file_path = path + str(seed) + out_extension
            sys.stderr.write("Reading solution from " + solution_file_path + ". ")
            solution_file = open(solution_file_path, "r")
            solution_list.append(read_solution(solution_file))
            solution_file.close()
            sys.stderr.write("Solution added. ")
            if "New bks was found." in line:
                sys.stderr.write("New bks.")
                has_bks = True
            sys.stderr.write("\n")
        else:
            sys.stderr.write("Failed... Check the log\n")
            if not error:
                error = True
            instances_error.append(path)

    if error:
        name = "*" + name #star signals that some runs contained errors. They should be checked.
    if has_bks:
        name = "+" + name #plus signals that at least 1 solution was saved as bks.

    entry = [name, path.replace(main_dir, ""), str(n_suc) + '/' + str(n_run)]
    entry.extend(add_entry(solution_list))
    return entry

#--Main-- Doesn't need to be modified
sys.stderr.write("Loading script parameter. Expecting the work folder.\n")
loadParam()
sys.stderr.write("Creating the summary file inside the folder.\n")
summary_file = open(os.path.join(main_dir, "result_summary.txt"), "w")
sys.stderr.write("Reading the initial lines of the log file.\n")
loadInfo()
sys.stderr.write("Loading problem info.\n")
loadProblemInfo()
sys.stderr.write("Checking instance log info and creating the table.\n")
loadInstanceListInfo()
sys.stderr.write("Saving the table and finishing the summary file.\n")
summary_file.write(str(table))
summary_file.write("\nLegend:\n* -- signals that at least one run has an error.\n+ -- signals that at least one solution was saved as new bks.\n! -- signals that the test battery used custom parameters to override defaults.\n# -- signals that the test battery was done with a instance that has appeared before in this summary.")


sys.stderr.write("Total amount of instances processed by this script from the log file: " + str(total_instances) + '\n')
summary_file.write("\n----------------\n\n")
summary_file.write("Number of instances processed by this script: " + str(total_instances) + '\n\n')

sys.stderr.write("Number of instances reported as not found: " + str(len(instances_not_found)) + '\n')
summary_file.write("Number of instances reported as not found: " + str(len(instances_not_found)) + '\n')
for i in instances_not_found:
    sys.stderr.write(i + '\n')
    summary_file.write(i + '\n')
summary_file.write("\n")

sys.stderr.write("Number of instances that has at least one run with error: " + str(len(instances_error)) + '\n')
summary_file.write("Number of instances that has at least one run with error: " + str(len(instances_error)) + '\n')
for i in instances_error:
    sys.stderr.write(i + '\n')
    summary_file.write(i + '\n')
summary_file.write("\n")

summary_file.close()
sys.stderr.write("Successfully finished.\n")
